<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Explore 3D Rooms – Free AI Charity</title>
  <meta name="description" content="Explore interactive 3D rooms highlighting the AI tools available on Free AI Charity.">
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="stylesheet" href="/assets/css/base.css"/>
  <style>
    html,body,#renderCanvas{width:100%;height:100%;margin:0;overflow:hidden;background:var(--bg);}    
    .nav{position:fixed;top:10px;left:10px;z-index:10;background:rgba(0,0,0,.35);padding:.5rem .75rem;border-radius:.75rem;border:1px solid rgba(255,255,255,.15);}    
    .nav a{color:#cde3ff;text-decoration:none;margin-right:.6rem;}
  </style>
</head>
<body>
  <div class="nav">
    <a href="/">← Home</a>
    <a href="#room1">Room 1: Text</a>
    <a href="#room2">Room 2: Images</a>
    <a href="#room3">Room 3: Music</a>
  </div>
  <canvas id="renderCanvas"></canvas>
  <script>
  // Simple 3D-like scene using HTML5 Canvas 2D
  (function(){
    const canvas = document.getElementById('renderCanvas');
    const ctx = canvas.getContext('2d');
    
    // Setup canvas
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resizeCanvas();
    
    // Scene state
    let cameraX = 0;
    let cameraY = 2;
    let cameraZ = 14;
    let rotationY = 0;
    let targetRotationY = 0;
    
    // Room definitions
    const rooms = [
      { x: -7, y: 0, z: 0, color: 'rgba(125, 211, 255, 0.8)', id: 'room1', name: 'Text' },
      { x: 0, y: 0, z: 0, color: 'rgba(167, 139, 250, 0.8)', id: 'room2', name: 'Images' },
      { x: 7, y: 0, z: 0, color: 'rgba(252, 165, 165, 0.8)', id: 'room3', name: 'Music' }
    ];
    
    let highlightedRoom = null;
    let highlightTime = 0;
    
    // Simple 3D projection
    function project3D(x, y, z) {
      // Apply camera rotation
      const cosY = Math.cos(rotationY);
      const sinY = Math.sin(rotationY);
      const rotatedX = x * cosY - z * sinY;
      const rotatedZ = x * sinY + z * cosY;
      
      // Translate by camera position
      const relX = rotatedX - cameraX;
      const relY = y - cameraY;
      const relZ = rotatedZ - cameraZ;
      
      // Project to 2D
      const distance = relZ + 20; // Prevent division by zero
      const scale = 800 / distance;
      const screenX = canvas.width / 2 + relX * scale;
      const screenY = canvas.height / 2 - relY * scale;
      
      return { x: screenX, y: screenY, scale: scale, depth: distance };
    }
    
    // Draw a 3D box
    function drawBox(x, y, z, width, height, depth, color, isHighlighted = false) {
      const corners = [
        { x: x - width/2, y: y - height/2, z: z - depth/2 },
        { x: x + width/2, y: y - height/2, z: z - depth/2 },
        { x: x + width/2, y: y + height/2, z: z - depth/2 },
        { x: x - width/2, y: y + height/2, z: z - depth/2 },
        { x: x - width/2, y: y - height/2, z: z + depth/2 },
        { x: x + width/2, y: y - height/2, z: z + depth/2 },
        { x: x + width/2, y: y + height/2, z: z + depth/2 },
        { x: x - width/2, y: y + height/2, z: z + depth/2 }
      ];
      
      const projected = corners.map(corner => project3D(corner.x, corner.y, corner.z));
      
      // Draw faces (simple approach - just draw visible faces)
      ctx.fillStyle = isHighlighted ? 'rgba(255, 255, 255, 0.9)' : color;
      ctx.strokeStyle = isHighlighted ? '#fff' : 'rgba(255, 255, 255, 0.3)';
      ctx.lineWidth = isHighlighted ? 2 : 1;
      
      // Front face
      ctx.beginPath();
      ctx.moveTo(projected[0].x, projected[0].y);
      ctx.lineTo(projected[1].x, projected[1].y);
      ctx.lineTo(projected[2].x, projected[2].y);
      ctx.lineTo(projected[3].x, projected[3].y);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      
      // Top face
      ctx.fillStyle = isHighlighted ? 'rgba(255, 255, 255, 0.7)' : color.replace('0.8', '0.6');
      ctx.beginPath();
      ctx.moveTo(projected[3].x, projected[3].y);
      ctx.lineTo(projected[2].x, projected[2].y);
      ctx.lineTo(projected[6].x, projected[6].y);
      ctx.lineTo(projected[7].x, projected[7].y);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      
      // Right face
      ctx.fillStyle = isHighlighted ? 'rgba(255, 255, 255, 0.5)' : color.replace('0.8', '0.4');
      ctx.beginPath();
      ctx.moveTo(projected[1].x, projected[1].y);
      ctx.lineTo(projected[5].x, projected[5].y);
      ctx.lineTo(projected[6].x, projected[6].y);
      ctx.lineTo(projected[2].x, projected[2].y);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
    }
    
    // Draw text in 3D space
    function drawText3D(text, x, y, z, size = 24) {
      const pos = project3D(x, y, z);
      if (pos.depth > 0) {
        ctx.fillStyle = 'white';
        ctx.font = `bold ${Math.max(12, size * pos.scale / 40)}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, pos.x, pos.y);
      }
    }
    
    // Animation loop
    function animate() {
      // Clear canvas
      ctx.fillStyle = '#0b0f18';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Smooth camera rotation
      rotationY += (targetRotationY - rotationY) * 0.1;
      
      // Update highlight
      if (highlightTime > 0) {
        highlightTime -= 16; // Roughly 60fps
      } else {
        highlightedRoom = null;
      }
      
      // Draw rooms
      rooms.forEach(room => {
        const isHighlighted = highlightedRoom === room.id && highlightTime > 0;
        drawBox(room.x, room.y, room.z, 6, 3, 6, room.color, isHighlighted);
        
        // Draw room labels
        drawText3D(room.name, room.x, room.y + 2.5, room.z, 20);
      });
      
      // Draw "TEXT AI" in first room
      drawText3D('TEXT AI', -7, 1.5, 3, 32);
      
      requestAnimationFrame(animate);
    }
    
    // Mouse controls
    let isMouseDown = false;
    let lastMouseX = 0;
    
    canvas.addEventListener('mousedown', (e) => {
      isMouseDown = true;
      lastMouseX = e.clientX;
    });
    
    canvas.addEventListener('mouseup', () => {
      isMouseDown = false;
    });
    
    canvas.addEventListener('mousemove', (e) => {
      if (isMouseDown) {
        const deltaX = e.clientX - lastMouseX;
        targetRotationY += deltaX * 0.01;
        lastMouseX = e.clientX;
      }
    });
    
    // Zoom with mouse wheel
    canvas.addEventListener('wheel', (e) => {
      cameraZ += e.deltaY * 0.01;
      cameraZ = Math.max(5, Math.min(30, cameraZ));
      e.preventDefault();
    });
    
    // Highlight function
    function highlight(roomId) {
      highlightedRoom = roomId;
      highlightTime = 800; // 800ms highlight duration
    }
    
    // Handle navigation
    window.addEventListener('hashchange', function(){
      const h = location.hash.replace('#','');
      if(h === 'room1'){ 
        targetRotationY = Math.PI * 0.3; // Rotate to focus on left room
        highlight('room1');
      }
      if(h === 'room2'){ 
        targetRotationY = 0; // Center view
        highlight('room2');
      }
      if(h === 'room3'){ 
        targetRotationY = -Math.PI * 0.3; // Rotate to focus on right room
        highlight('room3');
      }
    });
    
    // Handle window resize
    window.addEventListener('resize', function(){
      resizeCanvas();
    });
    
    // Start animation
    animate();
  })();
  </script>
</body>
</html>
